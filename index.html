<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Logger - High Quality</title>
    <link rel="manifest" href="/manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212;
            color: #E0E0E0;
        }
        .container {
            width: 100vw;
            height: 100vh;
        }
        video, canvas {
            /* The CSS width ensures it fits the screen, while JS sets the high resolution for drawing */
            max-width: 100%;
            border-radius: 0.75rem;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.25);
            background-color: #000;
        }
        .button-shadow {
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
        }
        #message-modal {
            background-color: rgba(0, 0, 0, 0.7);
        }
        .message-box {
            background-color: #2D2D2D;
            border: 1px solid #444;
        }
        /* Custom size for camera view in case native resolution is very large */
        #video-canvas {
            width: 100%;
            max-width: 800px; /* Limit display size for responsiveness */
            height: auto;
        }
    </style>
</head>
<body class="flex items-center justify-center p-4">
    <div class="container flex flex-col items-center justify-center p-4 space-y-4">
        <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-center">Video Logger (High Quality)</h1>
        <div class="relative w-full max-w-2xl">
            <video id="video-stream" class="hidden w-full h-auto" playsinline muted></video>
            <canvas id="video-canvas" class="w-full aspect-[4/3] sm:aspect-video"></canvas>
        </div>

        <div class="flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4 w-full max-w-2xl">
            <button id="start-stop-btn"
                    class="w-full sm:w-1/2 p-4 rounded-full text-lg font-medium transition-all duration-300 button-shadow
                           bg-green-600 hover:bg-green-700 text-white focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-900">
                Start Recording
            </button>
            <button id="toggle-camera-btn"
                    class="w-full sm:w-1/2 p-4 rounded-full text-lg font-medium transition-all duration-300 button-shadow
                           bg-gray-600 hover:bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-900 flex items-center justify-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                    <path d="M12 8c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zM12 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>
                    <path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10-4.48-10-10-10zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-4 7h8v2h-8v-2z"/>
                </svg>
                <span>Flip Camera</span>
            </button>
            <a id="download-link" href="#" download="recorded-video.webm"
               class="w-full sm:w-1/2 p-4 text-center rounded-full text-lg font-medium transition-all duration-300 button-shadow
                      bg-blue-600 hover:bg-blue-700 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-900 hidden">
                Download Video
            </a>
        </div>
        <div id="status-message" class="mt-4 text-center text-sm sm:text-base text-gray-400">
            Initializing camera and location...
        </div>
    </div>

    <div id="message-modal" class="fixed inset-0 z-50 flex items-center justify-center hidden">
        <div class="message-box p-6 rounded-lg shadow-xl max-w-sm w-full mx-4">
            <h3 id="modal-title" class="text-xl font-bold mb-2"></h3>
            <p id="modal-message" class="text-gray-300 text-sm"></p>
            <div class="mt-4 flex justify-end">
                <button id="modal-ok-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md">OK</button>
            </div>
        </div>
    </div>

    <script>
        const video = document.getElementById('video-stream');
        const canvas = document.getElementById('video-canvas');
        const context = canvas.getContext('2d');
        const startStopBtn = document.getElementById('start-stop-btn');
        const toggleCameraBtn = document.getElementById('toggle-camera-btn');
        const downloadLink = document.getElementById('download-link');
        const statusMessage = document.getElementById('status-message');
        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalOkBtn = document.getElementById('modal-ok-btn');

        let mediaRecorder;
        let recordedChunks = [];
        let videoStream;
        let geolocationWatcher;
        let lat = null;
        let lon = null;
        let recording = false;
        let animationFrameId;
        let facingMode = 'user'; // 'user' for front camera, 'environment' for back

        function showModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.classList.remove('hidden');
        }

        modalOkBtn.addEventListener('click', () => {
            messageModal.classList.add('hidden');
        });

        // ⭐ IMPROVEMENT: Set canvas dimensions to match native video resolution
        function setCanvasDimensions() {
            if (video.videoWidth > 0 && video.videoHeight > 0) {
                // Set the canvas's internal drawing surface size to the actual video resolution
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                // The CSS will handle scaling this high-resolution canvas to fit the screen
            }
        }

        function drawFrame() {
            if (video.videoWidth > 0 && video.videoHeight > 0) {
                setCanvasDimensions(); // Ensure dimensions are set correctly every frame
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Calculate font size based on canvas height for responsiveness
                const fontSize = Math.max(16, canvas.height / 30);
                context.font = `bold ${fontSize}px Inter, sans-serif`;

                // Overlay text settings
                const padding = 10;
                const textX = padding;
                let textY = canvas.height - padding;

                context.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Semi-transparent background

                // Add GPS coordinates (bottom-most text)
                if (lat !== null && lon !== null) {
                    const gpsText = `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}`;
                    const textMetrics = context.measureText(gpsText);
                    const boxHeight = fontSize + padding;
                    const boxWidth = textMetrics.width + 2 * padding;

                    context.fillRect(textX, textY - boxHeight, boxWidth, boxHeight);
                    context.fillStyle = 'white';
                    context.fillText(gpsText, textX + padding, textY - padding);
                    textY -= (boxHeight + padding / 2); // Move up for the next line
                }

                // Add timestamp (above GPS or bottom-most if no GPS)
                const now = new Date();
                const timestampText = now.toLocaleString();
                const textMetrics = context.measureText(timestampText);
                const boxHeight = fontSize + padding;
                const boxWidth = textMetrics.width + 2 * padding;

                context.fillStyle = 'rgba(0, 0, 0, 0.5)';
                context.fillRect(textX, textY - boxHeight, boxWidth, boxHeight);
                context.fillStyle = 'white';
                context.fillText(timestampText, textX + padding, textY - padding);
            }
            animationFrameId = requestAnimationFrame(drawFrame);
        }

        async function getVideoStream() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }

            try {
                // Request video and audio
                videoStream = await navigator.mediaDevices.getUserMedia({
                    // Use a common high-definition resolution for better quality
                    video: { facingMode: facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
                    audio: true
                });
                video.srcObject = videoStream;
                video.onloadedmetadata = () => {
                    video.play();
                    // Set initial dimensions and start drawing
                    setCanvasDimensions();
                    requestAnimationFrame(drawFrame);
                };
                statusMessage.textContent = "Ready to record. Video Resolution: " + video.videoWidth + "x" + video.videoHeight;
            } catch (err) {
                console.error("Error accessing video stream:", err);
                statusMessage.textContent = "Error: Camera access denied or not available.";
                showModal('Camera Access Denied', 'Please allow camera access to use this application.');
            }
        }

        function startGeolocationWatcher() {
            if ("geolocation" in navigator) {
                geolocationWatcher = navigator.geolocation.watchPosition(
                    (position) => {
                        lat = position.coords.latitude;
                        lon = position.coords.longitude;
                        statusMessage.textContent = `GPS Data: Lat ${lat.toFixed(5)}, Lon ${lon.toFixed(5)}. Ready to record.`;
                    },
                    (error) => {
                        // ... (Error handling remains the same)
                        let errorMessage = "Unable to get location data. Please enable location services.";
                        if (error.code === error.PERMISSION_DENIED) {
                            errorMessage = "Location access was denied. Please grant permission in your browser settings.";
                        } else if (error.code === error.POSITION_UNAVAILABLE) {
                            errorMessage = "Location information is unavailable. This may be due to a poor signal.";
                        } else if (error.code === error.TIMEOUT) {
                            errorMessage = "The request to get user location timed out.";
                        }
                        statusMessage.textContent = "Geolocation disabled or unavailable.";
                        showModal('Geolocation Error', errorMessage);
                    },
                    { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 } // High accuracy and reasonable timeout
                );
            } else {
                statusMessage.textContent = "Geolocation is not supported by your browser.";
                showModal('Geolocation Not Supported', 'Your browser does not support location services.');
            }
        }

        startStopBtn.addEventListener('click', () => {
            if (!recording) {
                // ⭐ IMPROVEMENT: Set a high bitrate (5 Mbps) and specify VP9 codec
                const options = {
                    mimeType: 'video/webm; codecs=vp9',
                    bitsPerSecond: 5000000 // 5 Megabits per second
                };

                const canvasStream = canvas.captureStream(30); // 30 FPS
                mediaRecorder = new MediaRecorder(canvasStream, options);
                recordedChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const videoURL = URL.createObjectURL(blob);
                    downloadLink.href = videoURL;
                    downloadLink.classList.remove('hidden');
                    startStopBtn.classList.remove('hidden');

                    // Reset button style
                    startStopBtn.textContent = "Start Recording";
                    startStopBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                    startStopBtn.classList.add('bg-green-600', 'hover:bg-green-700');

                    showModal('Recording Complete', 'Your high-quality video has been processed! Download it now.');
                };

                mediaRecorder.start();
                recording = true;
                startStopBtn.textContent = "Stop Recording";
                startStopBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                startStopBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                downloadLink.classList.add('hidden');
                statusMessage.textContent = "Recording...";
            } else {
                // Stop recording
                mediaRecorder.stop();
                recording = false;
                startStopBtn.textContent = "Processing...";
                startStopBtn.classList.add('hidden');
            }
        });

        toggleCameraBtn.addEventListener('click', () => {
            if (recording) {
                showModal('Cannot Switch Camera', 'Please stop the current recording before switching cameras.');
                return;
            }
            // Toggle the camera mode
            facingMode = facingMode === 'user' ? 'environment' : 'user';
            getVideoStream();
        });


        function stopRecording() {
            // No need to stop the animation frame or location watcher here, as they provide the overlays.
            // The unmounting function (window.onbeforeunload) handles a full stop.
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            if (geolocationWatcher) {
                navigator.geolocation.clearWatch(geolocationWatcher);
            }
        }

        // PWA Setup (remains the same)
        window.onload = function() {
            // Dynamically create a manifest.json file
            const manifest = {
                "name": "Video Logger HQ",
                "short_name": "VideoLoggerHQ",
                "description": "A high-quality video recorder with timestamp and GPS data.",
                "start_url": "./",
                "display": "standalone",
                "background_color": "#121212",
                "theme_color": "#2D2D2D",
                "icons": [
                    {
                        "src": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M18 10.48V6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-4.48l4 3.98v-11l-4 3.98zM16 18H4V6h12v12zM12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z' fill='%23FFFFFF'/%3E%3C/svg%3E",
                        "sizes": "192x192",
                        "type": "image/svg+xml"
                    },
                    {
                        "src": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M18 10.48V6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-4.48l4 3.98v-11l-4 3.98zM16 18H4V6h12v12zM12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z' fill='%23FFFFFF'/%3E%3C/svg%3E",
                        "sizes": "512x512",
                        "type": "image/svg+xml"
                    }
                ]
            };
            const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
            const manifestUrl = URL.createObjectURL(manifestBlob);
            document.querySelector('link[rel="manifest"]').href = manifestUrl;

            // Register the service worker (minimal, for PWA installability)
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register(
                    'data:application/javascript;base64,' + btoa(
                        'self.addEventListener("fetch", function(event) {});'
                    )
                ).then(function(reg) {
                    console.log('Service Worker registration successful with scope: ' + reg.scope);
                }).catch(function(err) {
                    console.log('Service Worker registration failed: ' + err);
                });
            }

            getVideoStream();
            startGeolocationWatcher();
        };

        // Handle page unload to stop media tracks
        window.onbeforeunload = function() {
            stopRecording();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        };
    </script>
</body>
</html>